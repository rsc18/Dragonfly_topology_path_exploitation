import os
import matplotlib.pyplot as plt
os.getcwd()
os.chdir(r'C:\Users\ramch\Dropbox\Dragonfly_topology_path_exploitation')

from graphCreationAndDraw import create_topology,draw_graph_circular
from dragonfly_minpath import generate_global_link_list_for_all_group_pairs, min_path_for_an_SD_pair, min_paths_for_all_SD_pairs, path_distribution_overall, path_distribution_analytical, different_group_nodes
#from randperm3 import get_traffic
from collections import defaultdict
import networkx as nx
import copy

def print_Path(p):
    for ele in p:
        print(ele.x,ele.y)

class FLOW():
    def __init__(self,s,d,num):
        self.s = s
        self.d = d
        self.min_path = []
        self.nonmin_path = [[-1] for _ in range(g)]
        self.min_path_throughput = {}
        self.nonmin_path_throughput = {}
        self.all_nonmin_path=[]
        self.id= num
        
    def print_flow(self):
        print(self.s,self.d)
        
    def linksCongestedWhenMerged(self,f1):
        a= self.min_path
        a=[(a[i],a[i+1]) for i, _ in enumerate(a[:-1])]
        b= f1.min_path
        b=[(b[i],b[i+1]) for i, _ in enumerate(b[:-1])]
        linksCongested =[]
        for ele1 in a:
            for ele2 in b:
                if ele1 == ele2:
                    linksCongested.append(ele1)
        return linksCongested
    
    def setMinPath(self):
        src_router = int(self.s/p)
        dest_router = int(self.d/p)
        min_path = SD_pairs_vs_minpaths[src_router,dest_router][0]
        min_path=[all_links[(min_path[i],min_path[i+1])] for i, _ in enumerate(min_path[:-1])]
        for lk in min_path:
            lk.add_minflow(self.num,0.0)
        self.min_path = min_path
        
        
    
    def setNonminPath(self):
        src_router = int(self.s/p)
        dest_router = int(self.d/p)
        src_group = int(src_router/a)
        dest_group = int(dest_router/a)        
        if src_group != dest_group:
            for intm_group in range(g):
                intm_grp_path=[]
                if (src_group != intm_group) and (dest_group!= intm_group):
                    for intm_router in range(intm_group*a, (intm_group*a) + a):
                        intm_path = SD_pairs_vs_minpaths[src_router,intm_router][0][:-1] + SD_pairs_vs_minpaths[intm_router,dest_router][0]
                        # print(intm_path)
                        intm_path=[all_links[(intm_path[i],intm_path[i+1])] for i, _ in enumerate(intm_path[:-1])]
                        intm_grp_path.append(intm_path)
                        self.all_nonmin_path.append(intm_path)
                    intm_grp_path.sort(key=len)   
                    self.all_nonmin_path.sort(key=len)
                    self.nonmin_path[intm_group] = intm_grp_path
                        
        if src_group == dest_group:
            intm_grp_path=[]
            for intm_router in range(src_group*a,(src_group*a) + a):
                if intm_router != src_router and intm_router!=dest_router:
                    intm_path = [src_router,intm_router,dest_router]
                    intm_path=[all_links[(intm_path[i],intm_path[i+1])] for i, _ in enumerate(intm_path[:-1])]
                    # print(intm_path)
                    intm_grp_path.append(intm_path)
                    self.all_nonmin_path.append(intm_path)
            intm_grp_path.sort(key=len)
            self.all_nonmin_path.sort(key=len)
            self.nonmin_path[0] = intm_grp_path
            
        for intm_grp_paths in self.nonmin_path:
            if intm_grp_paths!=[-1]:
                for vlb_paths in intm_grp_paths:
                    for lk in vlb_paths:
                        # self.print_flow()
                        # lk.print_link()
                        # print("\n")                        
                        lk.add_vlbflow(self.num,0.0)

            
    def update_paths(self):
        #if a link donot exist in all_links then remove the path
        #check min path
        for lk in self.min_path:
            if (lk.x,lk.y) not in all_links:
                self.min_path=[]
        all_nonmin_path = copy.deepcopy(self.all_nonmin_path)
        to_delete_index=[]
        for i,path in enumerate(all_nonmin_path):
            for lk in path:
                if (lk.x,lk.y) not in all_links:
                    # del self.all_nonmin_path[i]
                    to_delete_index.append(i)
        for ele in to_delete_index:
            print(ele)
            print(self.all_nonmin_path[ele])
            del self.all_nonmin_path[ele]
        
        #transfer shortest nonmin path as min path and remove from all_nonmin_path list
        self.min_path = self.all_nonmin_path[0]
        del self.all_nonmin_path[0]
        
               
class LINK():
    def __init__(self,id_link,x,y):
        self.id=id_link
        self.x = x
        self.y = y
        self.capacity = 1
        self.utilized = 0
        self.min_flows={}
        self.vlb_flows={}
        if int(x/a) == int(y/a):
            self.local_link = True
            self.global_link = False
        else:
            self.local_link = False
            self.global_link = True
            
    def print_link(self):
        print(self.x,self.y)
    
    def add_minflow(self,flow,load):
        self.min_flows[flow] = load
    
    def add_vlbflow(self,flow,load):
        self.vlb_flows[flow] = load
    
    # def get_flows(self):
    #     return flows
    
###########################################################
'''
todo:
    1. Get number of flows in each link
    2. Given a link identify flows that uses that link
    3. 
    
'''    
###########################################################


a,g,p=4,9,2
G = create_topology(a,g, arrangement = "absolute_improved")
draw_graph_circular(G, a)
group_pair_vs_global_links_dict=generate_global_link_list_for_all_group_pairs(G,a)
SD_pairs_vs_minpaths=min_paths_for_all_SD_pairs(G,a,group_pair_vs_global_links_dict)

H = G.to_directed()
        
all_links={}
for i,ele in enumerate(H.edges):
    all_links[ele] = (LINK(i,*ele))

all_links_cnt={}
for i,ele in enumerate(H.edges):
    all_links[ele] = (LINK(i,*ele))


def get_traffic():
    #Generate shift traffic
    src=[ele for ele in range(a*g*p)]
    dest=[(ele+(a*p))%(a*g*p) for ele in range(a*g*p)]
    trf=''
    for x,y in zip(src,dest):
        trf+=str(x)+" "+str(y)+"\n"
    return trf



sd_pair={}
trf=get_traffic()
trf=trf.split('\n')
for ele in trf[:-1]:
    src =int(ele.split()[0])
    dest =int(ele.split()[1])
    if src!=dest and int(src/p)!=int(dest/p):
        sd_pair[(src,dest)]=1.0
# assert(len(sd_pair)==(a**2)*g/2)
iteration=0

flow_list=[]
for ele in sd_pair:
    flow_list.append(FLOW(*ele))

for each_flow in  flow_list:
    each_flow.setMinPath()
    each_flow.setNonminPath()


injection_load = 0.5
min_percent = 20
vlb_percent  = 100 - min_percent

for each_flow in flow_list:
    min_path = each_flow.min_path
    min_load = (min_percent/100) * injection_load
    vlb_paths=[]
    for min_links in min_path:
        min_links.min_flows[each_flow]+=min_load
        
    for i in range(g):
        if each_flow.nonmin_path[i] !=[-1]:
            for vlb_path in each_flow.nonmin_path[i]:
                vlb_paths.append(vlb_path)

    vlb_load = ((vlb_percent/100) * injection_load)/ len(vlb_paths)
    for each_vlb_path in vlb_paths:
        for vlb_links in each_vlb_path:
            vlb_links.vlb_flows[each_flow]+=vlb_load
            if vlb_links == all_links[(1,3)]:
                each_flow.print_flow()
                print_Path(each_vlb_path)
                print("\n")
                                      

for ele,v in all_links[(1,3)].vlb_flows.items():
    ele.print_flow()
    print_Path(ele.min_path)
    print(v)

# all_min_paths = []
# for each_flow in flow_list:
#     all_min_paths.append(each_flow.min_path)

# min_path_link_utilized=defaultdict(int)
# for each_flow in all_min_paths:
#     for each_link in each_flow:
#         min_path_link_utilized[(each_link.x,each_link.y)] +=1

# #push traffic to min path with bottleneck load and update all link utilization
# bottleneck_throughput = 1/max(min_path_link_utilized.values())
# for each_flow in all_min_paths:
#     for each_link in each_flow:
#         each_link.utilized+=bottleneck_throughput

# for k,link in all_links.items():
#     print(k,link.utilized)
# for k,link in all_links.items():    
#     if link.utilized==1:
#         print(k,link.utilized)

# #delete the links that have utilization=1  and remove all paths that have these links
# link_keys = list(all_links.keys())
# for k in link_keys:    
#     if all_links[k].utilized<0.98:
#         del all_links[k]
        
# for each_flow in flow_list:
#     each_flow.update_paths()











        