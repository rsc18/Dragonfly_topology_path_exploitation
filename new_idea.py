import os
import matplotlib.pyplot as plt
os.getcwd()
os.chdir(r'C:\Users\ramch\Dropbox\Dragonfly_topology_path_exploitation')  

from graphCreationAndDraw import create_topology,draw_graph_circular
from dragonfly_minpath import generate_global_link_list_for_all_group_pairs, min_path_for_an_SD_pair, min_paths_for_all_SD_pairs, path_distribution_overall, path_distribution_analytical, different_group_nodes
#from randperm3 import get_traffic
from collections import defaultdict
import networkx as nx

# dfly(13,26,13,27), dfly(4,8,4,33), dfly(4,8,4,17), dfly(4,8,4,9).  
a,g,p=4,9,2
G = create_topology(a,g, arrangement = "absolute_improved")

# fig = plt.figure()
# draw_graph_circular(G, a)
group_pair_vs_global_links_dict=generate_global_link_list_for_all_group_pairs(G,a)
SD_pairs_vs_minpaths=min_paths_for_all_SD_pairs(G,a,group_pair_vs_global_links_dict)
    
glinks = []
for k,v in group_pair_vs_global_links_dict.items():
    for ele in v:
        glinks.append((ele[0],ele[1]))
    
ag_links=[]
for ele in glinks:
    ag_links.append(ele)
    ag_links.append((ele[1],ele[0]))

# with open('27G-topo','w') as fp:
#     for ele in ag_links:
#         fp.write(str(ele[0])+" "+str(ele[1]) +' 1\n')

topo=[]    
for router_id in range(a*g):
    xx=[-1000]*a*g
    router_grpid = int(router_id/a)
    for i in range(router_grpid*a,(router_grpid*a)+a):
        xx[i]=0
    topo.append(xx)

import numpy as np
topo=np.asanyarray(topo)

for ele in ag_links:
    topo[ele[0]][ele[1]]=0

# fig = plt.figure()
# xx=[]
# yy=[]
# ax = fig.add_axes([0.1, 0.1, 0.8, 0.8]) # main axes
# for i,_ in enumerate(topo):
#     for j,_ in enumerate(topo[i]):    
#         xx.append(i)
#         yy.append(j)
# # plt.scatter(xx, yy, color='white', s=40)
# ax.imshow(topo,origin='lower')
# ax.set_xticks([ele for ele in range(a*g)])
# ax.set_yticks([ele for ele in range(a*g)])

def get_sd_min_path(i):
    if i==0:
        SD_pairs_vs_minpaths=min_paths_for_all_SD_pairs(G,a,group_pair_vs_global_links_dict)
        return SD_pairs_vs_minpaths
    else:
        return None

def plot_topo(H,title):
    plt.figure()
    plt.title(title)
    pos = nx.circular_layout(H)
    nx.draw(H,pos,with_labels=True)
    edge_labels = nx.get_edge_attributes(H, "weight")
    edge_labels = {k:round(v,2) for k,v in edge_labels.items()}
    nx.draw_networkx_edge_labels(H, pos, edge_labels)

H = G.to_directed()
for ele in H.edges:
    H.add_weighted_edges_from([(*ele,1)])
# plt.figure()
# pos = nx.circular_layout(H)
# nx.draw_networkx_nodes(H, pos)
# nx.draw_networkx_edges(H, pos)
# edge_labels = nx.get_edge_attributes(H, "weight")
# nx.draw_networkx_edge_labels(G, pos, edge_labels)

sd_pair={}
# from randperm3 import get_traffic
import random

def get_mixed_traffic(traffic_name,percent):
    #Generate shift traffic
    src=[]
    dest=[]    
        
    if traffic_name=="rbmixed":
        routers = [ele for ele in range(a*g)]
        random.shuffle(routers)
        src_routers = random.sample(routers,int(percent*len(routers)/100))
        for sw in range(a*g):
            for nd in range(p):
                src.append(sw*p+nd)
                if sw in src_routers:                    
                    dest.append(((sw*p+nd) + a*p) % (a*g*p))
                else:
                    dest.append(-1)
    trf=''
    for x,y in zip(src,dest):
        trf+=str(x)+" "+str(y)+"\n"
    return trf


def get_traffic(traffic_name):
    #Generate shift traffic
    src=[]
    dest=[]
    
    if traffic_name=="shift":
        src=[ele for ele in range(a*g*p)]
        dest=[(ele+(a*p))%(a*g*p) for ele in range(a*g*p)]
    if traffic_name=="randperm":
        src=[ele for ele in range(a*g*p)]
        dest=[ele for ele in range(a*g*p)]
        random.shuffle(dest)
    
    
    # if traffic_name=="shifthalf_rev":
    #     nodes=[ele for ele in range(a*g*p)]
    #     for ele in nodes:
    #         src.append(ele)
    #         if ele%2==0:
    #             dest.append((ele+(a*p))%(a*p*g))
    #         else:
    #             dest.append((ele-(a*p))%(a*p*g))
    
    if "shifthalf" in traffic_name:
        g1= int(traffic_name.split(",")[0][-1])
        g2 = int(traffic_name.split(",")[1][0])
        assert(type(g1)==int)
        assert(type(g2)==int)
        src_grps = [ele for ele in range(g)]
        dest_grps= [((ele+g1)%g,(ele+g2)%g) for ele in src_grps]
        
        groups_queue = [0]*g
        for i,ele in enumerate(groups_queue):
            groups_queue[i]=[]
            for j in range(a*p):
                groups_queue[i].append((i*a*p)+j)
                
        src=[]
        dest=[]
        for i,ele in enumerate(src_grps):
            src_nodes = [ele*(a*p)+i for i in range(a*p)] 
            dest_nodes=[]
            #divide source nodes by dest_grps pair length
            num_dest_grps = len(dest_grps[i])
            for dg in dest_grps[i]:
                for _ in range(int(len(src_nodes)/num_dest_grps)):
                    dest_nodes.append(groups_queue[dg].pop())
            for ele in src_nodes:
                src.append(ele)
            for ele in dest_nodes:
                dest.append(ele)
            
                
    if traffic_name=="outgroup":
        groups_queue = [0]*g
        for i,ele in enumerate(groups_queue):
            groups_queue[i]=[]
            for j in range(a*p):
                groups_queue[i].append((i*a*p)+j)
        src=[]
        dest=[]
        
        
        
    trf=''
    for x,y in zip(src,dest):
        trf+=str(x)+" "+str(y)+"\n"
    return trf

trf=get_traffic('randperm')
trf=trf.split('\n')
for ele in trf[:-1]:
    src =int(ele.split()[0])
    dest =int(ele.split()[1])
    sd_pair[(src,dest)]=1.0
# assert(len(sd_pair)==(a**2)*g/2)
iteration=0

links=defaultdict(int)
link_flow=defaultdict(list)
min_path_sd = {} # Store the min-path 

ll=(0,0)
temp_prev=0    
SD_pairs_vs_minpaths = get_sd_min_path(iteration)
to_remove = {}
for ele_node in sd_pair:
    #convert sd node pair ele to sd router pair ele 
    router_ele=(int(ele_node[0]/int(a/2)),int(ele_node[1]/int(a/2)))
    #if src router and destination router are not same
    if(router_ele[0]!=router_ele[1]):
        #Get the min path for sd flow where min_path is a tuple data type
        if SD_pairs_vs_minpaths:
            min_path = SD_pairs_vs_minpaths[router_ele][0]
        else:
            try:
                min_path = tuple(nx.shortest_path(H,router_ele[0],router_ele[1]))
            except:
                print("****************************")
                to_remove[ele_node] = sd_pair[ele_node]
                print(to_remove)
                break
        min_path_sd[ele_node] = min_path
        # This loop gives number of flows a link is sharing and also from where those flows are coming
        #add a picture
        for i in range(len(min_path[:-1])):
            # get the link in a path
            ll=(min_path[i],min_path[i+1])                
            #incremenet the link useage by 1
            if(min_path[i]<min_path[i+1]):
                links[ll] +=1
            else:
                links[ll] -=1
            if(ll==(26,30)):
                print(min_path,links[ll])
            #ele[i] is not a src routter
            if i-1>=0:
                link_flow[ll].append((min_path[i-1],min_path[i],min_path[i+1]))
            else:
                link_flow[ll].append(('t-'+str(temp_prev),min_path[i],min_path[i+1]))
                # print(('t-'+str(temp_prev),min_path[i],min_path[i+1]))
                temp_prev+=1

min_path_max_flow=defaultdict(int)
for ele_node in sd_pair:
    router_ele=(int(ele_node[0]/int(a/2)),int(ele_node[1]/int(a/2)))
    if(router_ele[0]!=router_ele[1]):
        min_path = min_path_sd[ele_node]
        for i in range(len(min_path[:-1])):
            ll=(min_path[i],min_path[i+1])
            min_path_max_flow[ele_node]=max(min_path_max_flow[ele_node],links[ll])
    else:
        print(ele_node, router_ele)

for k,v in links.items():
    topo[k[0]][k[1]] = v
    
    
import matplotlib
masked_array = np.ma.masked_where(topo == -1000, topo)
masked_array2 = np.ma.masked_where(masked_array == 0, topo)
cmap = matplotlib.cm.RdYlBu  # Can be any colormap that you want after the cm

plt.figure()
plt.imshow(topo,cmap=cmap, aspect='auto',origin='lower')
cmap.set_bad(color='white')
plt.imshow(masked_array, cmap=cmap,origin='lower')
plt.colorbar()



