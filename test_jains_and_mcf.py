import networkx as nx
import time
import random
import datetime
import os
import sys
import re
import pickle

import utilites as ut
import topologies as tp

from djkstra import all_pair_all_shortest_paths_djkstra
from Dragonfly_paths import all_pair_all_min_paths_DF
from jains import jains_model, jains_model_with_unique_pairs
from mcf import create_mcf_rules

from path_manipulation import create_MIN_paths_list, create_VLB_paths_list, merge_MIN_and_VLB_paths
from traffic import create_random_permutation_pattern, check_pattern_for_duplicates, create_shift_traffic_pattern, create_df_wc_traffic_pattern

def create_topology(a, g, arrangement, seed = 0):
    
    start_time = time.time()
    G, local_links, global_links = tp.build_drgonfly(a=a, p=a // 2, h=a // 2, gl_arrangmnt=arrangement, g=g, seed = seed)
    
    #    print("test printing the global links:")
    #    for idx, (link, props) in enumerate(global_links.items()):
    #        print(idx,link,props)
    #        
    #    print("test printing the local links:")
    #    for idx, (link, props) in enumerate(local_links.items()):
    #        print(idx,link, props)
    
    
    end_time = time.time()
    
    print("topology creation time:", end_time - start_time)
    
    if ut.validate_DF(G,global_links,local_links,a,g):
        print("Valid topology")
        validity = "Valid"
    else:
        print("Invalid topology")
        validity = "Invalid"
    
    return G
    
    pass

def draw_graph_circular(G, a = 1):
            
    colors = ['green', 'red','cyan','blue','yellow','magenta', 'lightgreen', 'slategray','coral', 'brown', 'gold', 'lightpink', ]
    
    node_colors = [colors[(x//a)%len(colors)] for x in G.nodes]
    
    edge_colors = [colors[edge[2]["w"]] for edge in G.edges(data=True)]
    
    options = {
        "node_color" : node_colors,
        "width" : 1,
        "edge_color" : edge_colors,
        "with_labels": True,
        "node_size" : 600
    }
    
    
    #nx.draw_circular(G, **options)
    pos = nx.circular_layout(G) 
    
    nx.draw(G, pos = pos , **options)
    
    #edge_labels = nx.get_edge_attributes(G,"w")
    #nx.draw_networkx_edge_labels(G, pos = pos, edge_labels = edge_labels)
        

    #plt.show()
    pass



def test_jains(a, g, pattern = None, routing = "MIN", file_pointer = None):
    '''
    So far, routing can be only MIN or VLB, or Combined
    '''
    
    print("\n\ninside test_jains ...")
    start_time = time.time()
    
    
    #create a Dragonfly topology
    #a = 8
    #g = 29
    h = a//2
    p = a//2
    arrangement = "absolute_improved"
    
    print("a, g, arrangement : ", a, g, arrangement)
    
    G = create_topology(a,g,arrangement)
    if draw == True:
        draw_graph_circular(G, a = a)
        
    if pattern == "randperm":
        seeds = [0, 2]  
        #TODO: we need to parameterize seeds later
    elif pattern == "shift":
        seeds = [0]   # seed is not needed for shift
    else:
        print("Error! Unsupported traffic pattern!")
        sys.exit(1)

        
    for seed in seeds:
        #create a traffic pattern
        if pattern == "randperm":
            traffic = create_random_permutation_pattern(a = a, g = g, seed = seed, verbose = False)
        elif pattern == "shift":
            traffic = create_shift_traffic_pattern(a = a, g = g,  verbose = False)
            
        tot_sd_pairs = len(traffic)
        traffic_and_freqs = check_pattern_for_duplicates(traffic, verbose = False)
        tot_unique_pairs = len(traffic_and_freqs)
        
        #create path list
            #test with both min and vlb, one by one
        all_djkstra_paths = all_pair_all_shortest_paths_djkstra(G, edge_weight = "w")
        
        modes = [0, 1, 3] #mode 1 and 2 are practically equivalent, so skipping 2
        
        for mode in modes:
        
            if routing == "MIN":
                paths = create_MIN_paths_list(G, traffic, all_pair_min_paths = all_djkstra_paths, verbose = False)
            elif routing == "VLB":
                paths = create_VLB_paths_list(G, a, traffic, all_pair_min_paths = all_djkstra_paths, verbose = False)
            elif routing == "Combined":
                paths = merge_MIN_and_VLB_paths(G, a, traffic, all_pair_min_paths = all_djkstra_paths, mode = mode, verbose = False)
            #call JM
            print("\ncalling JM for routing {}, seed {} and mode {} ".format(routing, seed, mode))
            #total_bw, res = jains_model(G = G, traffic = traffic,   path_list = paths, verbose = False)
            total_bw, result_bw = jains_model_with_unique_pairs(G = G, traffic_and_freqs = traffic_and_freqs,  path_list = paths, verbose = False)
            
            print("out of JM ...")
            print("\ntotal_bw: " , total_bw)
            print("result: " , result_bw)
            
            #do file writing here.
            print("{},{},{},{},{},{},{},{},{},".format(a,g,h,p,arrangement,pattern,seed,tot_sd_pairs,tot_unique_pairs))
            if file_pointer:
                file_pointer.write("{},{},{},{},{},{},{},{},{},".format(a,g,h,p,arrangement,pattern,seed,tot_sd_pairs,tot_unique_pairs))
            print("{},{},{:.4f},{:.4f}".format(routing, mode, total_bw, result_bw))
            if file_pointer:
                file_pointer.write("{},{},{:.4f},{:.4f}".format(routing, mode, total_bw, result_bw))
                file_pointer.write("\n")

            #win
            end_time = time.time()
            print("total time spent:", end_time - start_time)
        
    pass

def test_jains_script():
    #call with "python3 -u" to facilitate output flushing
    
    #test with a few differnt-sized DF
        #a = 16
        #g = 3, 10, 20, 40, 60, 100, 129
        
    #For each config, call JM. time it. 
    
    #Gs = [20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 80, 90, 100, 110, 120, 129]
    #a = 16
    
    
    Gs = [4,7,9]
    a = 4
    routing = "Combined"
    
    pattern = "shift" #options: shift, randperm
    
    #create output file
    now = datetime.datetime.now()
    
    foldername = "Jains_Test_Result"
    os.makedirs(foldername, exist_ok = True)
    
    outfilename = "a_{}_routing_{}_trafficpattern_{}_datetime_{}_{}_{}_{}_{}_{}.res".format(a,routing,pattern, now.year, now.month, now.day, now.hour, now.minute, now.second)
    
    fp = open(foldername + "/" + outfilename, "w")
    
    fp.write("a,g,h,p,arrangement,pattern,seed,tot_sd_pairs,tot_unique_pairs,routing,mode,total_bw,result_bw,\n")
    
    for g in Gs:
        #for routing in ["MIN", "VLB", "Combined"]:
        test_jains(a, g, pattern, routing, fp)
        
    fp.close()
    pass

def test_traffic_pattern_creation():
    #start_time = time.time()
    a = 4
    g = 5
    arrangement = "absolute_improved"
    
    G = create_topology(a,g,arrangement)
    draw_graph_circular(G, a = a)

    SDpairs = create_shift_traffic_pattern(a = a, g = g,  verbose = True)
    
    pass


def create_cplex_script(foldername, filename):
    
    '''
    Contents of a typical script file:
        read a8_g25_absolute_improved_rperm_seed10_mode_regular.lp
        optimize
        display solution var x*
    '''
    
    fp = open(foldername + "/" + "script", "w")
    
    complete_filename =  foldername + "/" + filename
    
    fp.write("read {}\n".format(complete_filename))
    fp.write("optimize\n")
    fp.write("display solution var x*\n")
    fp.write("display solution var m*\n")
    fp.write("display solution var v*\n")
    
    fp.close()
    
    print("script created.")
    pass


def run_cplex_and_collect_results(lp_foldername, res_foldername, filename):
    '''
    Take the name of the cplex file.
    Run it from command prompt.
    Save the result in an output file.
    Parse the output file to get the throughput value.
    Return the throuhput value.
    
    filename: the complete path to the lp file.
    '''
    
    outfilename = res_foldername + "/" + filename + ".res"
    scriptfilename = lp_foldername + "/" + "script"
    
    command = "cplex -f {} > {}".format(scriptfilename, outfilename)
    
    print("running command: ", command)
    os.system(command)
    print("command ran.")
    
    results = extract_results(outfilename, ["x"]) #can collect "m" and "v" varibles as well in this way
    
    return results


def extract_results(filename, var_name_prefixes = ["x"]):

    '''
    Sampel patterns: 
        x                             0.333333
        m_0_5                         0.333333
    '''
    
    results = []
    
    for var_name_prefix in var_name_prefixes:
        pattern = r"{}\S*\s+[\d.]+".format(var_name_prefix)
        p = re.compile(pattern)
        
        fp = open(filename, "r")
            #reopening the file for each variable group to set the file pointer at the beginning.
        for line in fp:
            if p.match(line):
                #pattern matched. Then chop the string
                res = line.split()
                results.append((res[0], float(res[1])))    
        fp.close()    
    
    return results
    
    pass

#def run_mcf(*, a, g, arrangement, traffic, traffic_param_value, traffic_param_value2, G, all_min_paths_DF, all_djkstra_paths, SDpairs, traffic_param, topFolderName, modes, models):

def run_mcf(**kwargs):
    
    #get assigns a default value of None if the key is not found 
    a = kwargs.get("a")
    g = kwargs.get("g")
    arrangement = kwargs.get("arrangement")
    traffic = kwargs.get("traffic")
    traffic_param_value  = kwargs.get("traffic_param_value")
    traffic_param  = kwargs.get("traffic_param")
    traffic_param_value2  = kwargs.get("traffic_param_value2")
    G = kwargs.get("G")
    all_min_paths_DF  = kwargs.get("all_min_paths_DF")
    all_djkstra_paths  = kwargs.get("all_djkstra_paths")
    SDpairs  = kwargs.get("SDpairs")
    topFolderName  = kwargs.get("topFolderName")
    modes = kwargs.get("modes")
    models = kwargs.get("models")
    
    print("\n\nstarting run_mcf() for a {} g {} traffic {} traffic_param_value {} traffic_param_value2 {}.".format(a, g, traffic, traffic_param_value, traffic_param_value2))
    
     
    print("calling mcf ...")
    
    lp_foldername = topFolderName + "/Models" 
    lp_res_foldername = topFolderName + "/LP_Results" 
    os.makedirs(lp_foldername , exist_ok = True)
    os.makedirs(lp_res_foldername , exist_ok = True)
    
    
    #modes = ["minimal_only", "vlb_only", "4hop_paths_only", "5hop_paths_src_only", "5hop_paths_src_and_dst", "regular", "5hop_and_6hop"]
    #modes = ["4hop_paths_only","5hop_paths_src_only", "5hop_paths_src_and_dst","5hop_and_6hop","regular"]
    
    #right now, only meaningful mode_param is for mode "5hop_and_6hop", "4hop_and_5hop".
    #For it, the value x means x% of the remaining 6hop inodes.
    #For every other mode, a default value of 0 is placed which will be ignored by the mcf function.
    mode_params = {"minimal_only" : [0], 
                   "vlb_only" : [0],
                   "4hop_paths_only" : [0], 
                   "5hop_paths_src_only" : [0], 
                   "5hop_paths_src_and_dst" : [0], 
                   "regular" : [0], 
                   #"5hop_and_6hop" : [10, 20, 40, 60, 80]
                   "4hop_and_5hop" : [10, 20, 30, 40, 50, 60, 70, 80, 90 ], 
                   "5hop_and_6hop" : [10, 20, 30, 40, 50, 60, 70, 80, 90 ] ,
                   "3hop_paths_only": [0],
                   "3hop_and_4hop" : [10, 20, 30, 40, 50, 60, 70, 80, 90 ] ,
                   }
    
    #min_pathslist is same for all the modes
    #vlb_pathlist varies depending on mode
    
    vlb_pathlist_dict = {"regular" : all_min_paths_DF, 
                         "minimal_only": all_min_paths_DF,  
                                 #in this case the vlb_path_list will not be used. So we could've
                                 #sent an empty list. This will be controlled by the inode_generator function.
                         "vlb_only": all_min_paths_DF,  
                         "4hop_paths_only": all_djkstra_paths, 
                         "5hop_paths_src_only": all_djkstra_paths, 
                         "5hop_paths_src_and_dst": all_djkstra_paths, 
                         "4hop_and_5hop": all_djkstra_paths,
                         "5hop_and_6hop": all_djkstra_paths,
                         "3hop_paths_only": all_djkstra_paths,
                         "3hop_and_4hop": all_djkstra_paths,
                         
                         }
    
    result_list = []
    
    for model_no in models:
        for mode in modes:
            for mode_param in mode_params[mode]: 
                filename =  "a{}_g{}_{}_{}_{}{}_mode_{}_model_{}.lp".format(a,g,arrangement,traffic, traffic_param, traffic_param_value, mode, model_no)
                complete_filename = lp_foldername + "/" + filename
                
                #create_mcf_rules_model_3(*,G, a, g, model, minpathlist, vlbpathlist, sd_pairs, filename, mode, mode_param)
                
                #create_mcf_rules(G = G, a = a, g = g, model = model_no, minpathlist = all_min_paths_DF, vlbpathlist = vlb_pathlist_dict[mode], sd_pairs = SDpairs, filename = complete_filename, mode = mode, mode_param = mode_param)
                kwargs = {"G" : G, 
                          "a" : a, 
                          "g" : g, 
                          "model" : model_no, 
                          "minpathlist" : all_min_paths_DF, 
                          "vlbpathlist" : vlb_pathlist_dict[mode], 
                          "sd_pairs" : SDpairs, 
                          "filename" : complete_filename, 
                          "mode" : mode, 
                          "mode_param" : mode_param}
                
                create_mcf_rules(**kwargs)

                create_cplex_script(lp_foldername, filename)
            
                result = run_cplex_and_collect_results(lp_foldername, lp_res_foldername, filename)
                
                result_x = result[0][1] #Hack. Just picking the value fo x this way.
                
                print("a, {}, g ,{}, traffic, {}, {}, {}, traffic_param_val2, {}, model, {}, mode, {}, mode_param, {}, throughput, {}".format(a, g, traffic, traffic_param, traffic_param_value, traffic_param_value2,  model_no, mode, mode_param, result_x))
                
                result_list.append([a,g,traffic, traffic_param_value, traffic_param_value2, model_no, mode, mode_param, result_x])
            
            #print("throughput: ", result_x)
    
        #draw_graph_circular(G, a = a)
        
    return result_list

    pass


def inode_generator_test():
    import Dragonfly_paths as DP
    from mcf import inode_generator_5hop_and_6hop, inode_generator_4hop_and_5hop, inode_generator_3hop_and_4hop 
    #def inode_generator_5hop_and_6hop(src, dst, N, a, *, twoHopNeighborList, sd_pair_vs_4hop_inodes = None , mode_param)
    
    a = 4
    g = 9
    p = a//2
    arrangement = "absolute_improved"
    G = create_topology(a,g,arrangement)
    group_pair_vs_global_links = DP.get_list_of_links_between_each_group_pair(G, edge_weight = "w", a = a, g = g )    
    #to be passed to mcf functions
    twoHopNeighbors =  DP.generate_list_of_2hop_neighbors(G, group_pair_vs_global_links, edge_weight = "w", a = a, g = g)
    
    graph_adj_list = DP.generate_graph_adjacency_list(G)
    group_pair_vs_nodes = DP.generate_list_of_nodes_connected_to_group_pairs(graph_adj_list, a)
        
    traffic = "rperm"
    seed = 42
    sd_pairs, traffic_param = create_traffic_pattern(a,g,traffic, seed)
    
    sd_pair_vs_4hop_inodes = DP.inodes_for_4hop_paths_for_all_SD_pairs(sd_pairs, G, graph_adj_list, group_pair_vs_nodes, edge_weight = "w", a = a, g = g, p = p)
    
    sd_pair_vs_3hop_inodes = DP.inodes_for_3hop_paths_for_all_SD_pairs(sd_pairs, G, graph_adj_list,  twoHopNeighbors, edge_weight = "w", a = a, g = g, p = p)
    
#    for pair in sd_pairs:
#        print(pair)
  
    N = len(G)
    src = 71//p
    dst = 14//p
    mode_param = 20
    
    #inode_generator_5hop_and_6hop(src, dst, N, a, twoHopNeighborList= twoHopNeighbors, sd_pair_vs_4hop_inodes = sd_pair_vs_4hop_inodes ,sd_pair_vs_3hop_inodes = sd_pair_vs_3hop_inodes, mode_param = mode_param)
    #inode_generator_4hop_and_5hop(src, dst, N, a, twoHopNeighborList= twoHopNeighbors, sd_pair_vs_4hop_inodes = sd_pair_vs_4hop_inodes , mode_param = mode_param)
    inode_generator_3hop_and_4hop(src, dst, N, a,  twoHopNeighborList= twoHopNeighbors, sd_pair_vs_4hop_inodes =sd_pair_vs_4hop_inodes, sd_pair_vs_3hop_inodes = sd_pair_vs_3hop_inodes, mode_param = mode_param)
    
    draw_graph_circular(G, a = a)
    
    pass

def create_topology_and_pathlist(a,g,arrangement):
    G = create_topology(a,g,arrangement)

    all_min_paths_DF = all_pair_all_min_paths_DF(G, edge_weight = "w", a = a, g = g)
    all_djkstra_paths = all_pair_all_shortest_paths_djkstra(G, edge_weight = "w")
    
    return G, all_min_paths_DF, all_djkstra_paths
    

def create_traffic_pattern(a, g, traffic, traffic_param_value, traffic_param_value2 = 0):
    if traffic == "shift":
        SDpairs = create_shift_traffic_pattern(a = a, g = g, shift_by = traffic_param_value, shift_by_router=traffic_param_value2, router_level = False, verbose = False)
        traffic_param = "shift_by"
        
    elif traffic == "rperm":
        # SDpairs = create_random_permutation_pattern(a = a, g = g, seed = traffic_param_value, verbose = False)
        src_dest_map={}    
        p=4
        src=[ele for ele in range(a*g*p)]
        for ss in src:
            src_grp=int(ss/(a*p))
            node_index=ss%(a*p)  
            dest_grp=[ele for ele in range(33)]
            dest_grp.remove(src_grp)
            if src_grp!=32:
                src_dest_map[ss]=(dest_grp[node_index]*32) + src_grp
        remaing_nodes=[(ele*32)+ele for ele in range(32)]
        for i in range(32):
            ss=(32*32)+i
            dd=remaing_nodes[i]
            src_dest_map[ss]=dd
            
        SDpairs=[]
        for k,v in src_dest_map.items():
            SDpairs.append((k,v))
            
        traffic_param = "seed"
        
    elif traffic == "df_wc":
        SDpairs = create_df_wc_traffic_pattern(a = a, g = g, seed = traffic_param_value, verbose = False)
        traffic_param = "seed"
        
        
    else:
        print("Error. Unsupported traffic: ", traffic)
        sys.exit(-1)
    
    return SDpairs, traffic_param

def test_mcf():
    '''
    Run a single isntance of mcf. Just for test.
    '''
    
    start_t = time.time()
    
    a = 8
    g = 5
    arrangement = "absolute_improved"
    traffic = "df_wc"
    traffic_param_value = 1
    traffic_param_value2 = 0
    
    #mcf_path_selection_modes = ["4hop_paths_only","4hop_and_5hop","5hop_paths_src_only", "5hop_paths_src_and_dst", "5hop_and_6hop", "regular"]
    
    mcf_path_selection_modes=["regular"]
    models = [3]    
    topFolderName = "Temp"
    
    #traffic_param_values = { "shift" : [1,2] }
    
#    traffic_param_values = { "shift" : [1,2,3,4], 
#                            "rperm" : [10,11,12,13]}
#        #for rperm, this is perm_seed
        #for shift, it is shift_by(group)



    #this is where we should create the topology,
    #create the list of paths, and other necessary stats.
    #Then we should pass it. That way, we won't have to do that again and again.
    #But, later. First, work on adding more inode-options.
    G, all_min_paths_DF, all_djkstra_paths = create_topology_and_pathlist(a,g,arrangement)
                
    SDpairs, traffic_param = create_traffic_pattern(a, g, traffic, traffic_param_value, traffic_param_value2)
            
    kwargs = {"a" : a, 
              "g" : g, 
              "arrangement" : arrangement, 
              "traffic" : traffic, 
              "traffic_param_value" : traffic_param_value, 
              "traffic_param_value2" : traffic_param_value2, 
              "G" : G, 
              "all_min_paths_DF" : all_min_paths_DF, 
              "all_djkstra_paths" : all_djkstra_paths, 
              "SDpairs" : SDpairs, 
              "traffic_param" : traffic_param, 
              "topFolderName" : topFolderName, 
              "modes" : mcf_path_selection_modes, 
              "models" : models}
    
    temp_result = run_mcf(**kwargs)    
            
    end_t = time.time()
    elapsed = end_t - start_t
    
    print("total time: {} secs / {:.2f} mins".format(elapsed, elapsed/60))
    
    
    
    pass

def experiment_mcf(Gs):
    '''
    Vary a, g, traffic, shift_by, perm_seed from here.
    For each configuration, mcf will run for "min", "regular", and "2hop_restrcited" modes. 
    '''
    
    start_t = time.time()
    
    As = [4]
    #Gs = [3,5,9,17,25,33]
    # Gs = [5]
    arrangement = "absolute_improved"
    
    traffics = ["shift"]
        #options: shift / rperm / df_wc
    #filename_prefix = "Experiment"
    
    groupname_string = "_".join([str(x) for x in Gs])
    filename_prefix = "A8_G_{}__model3_pathlen_constraint_added__3hop_and_3hop4hop_modes".format(groupname_string)
    
    topFolderName = "LP_modeling_Sept_2023"
    
    # mcf_path_selection_modes = ["3hop_paths_only","3hop_and_4hop", "4hop_paths_only","4hop_and_5hop","5hop_paths_src_only", "5hop_paths_src_and_dst", "5hop_and_6hop", "regular"]
    mcf_path_selection_modes = ["regular"]
    
    models = [3]
    
    #traffic_param_values = { "shift" : [1,2] }
    
#    traffic_param_values = { "shift" : [1,2,3,4], 
#                            "rperm" : [10,11,12,13]}
#        #for rperm, this is perm_seed
        #for shift, it is shift_by(group)



    results_dict = {"columns" : [], "results" : []}
        
    result_list = []
    
    for a in As:
        for g in Gs:
            #this is where we should create the topology,
            #create the list of paths, and other necessary stats.
            #Then we should pass it. That way, we won't have to do that again and again.
            #But, later. First, work on adding more inode-options.
            G, all_min_paths_DF, all_djkstra_paths = create_topology_and_pathlist(a,g,arrangement)
            
            for traffic in traffics: 
                for traffic_param_value in range(0,1):    #change from 8 to g for other tests
                    #for shift_by_router in range(0,a):
                        SDpairs, traffic_param = create_traffic_pattern(a, g, traffic, traffic_param_value)
                        
                        temp_result = run_mcf(a = a, g = g, arrangement = arrangement, traffic = traffic, traffic_param_value = traffic_param_value, traffic_param_value2 = 0,  G = G, all_min_paths_DF = all_min_paths_DF, all_djkstra_paths = all_djkstra_paths, SDpairs = SDpairs, traffic_param = traffic_param, topFolderName = topFolderName, modes = mcf_path_selection_modes, models = models)    
                        
                        
                        result_list.extend(temp_result)
        
    results_dict["columns"] = ["a","g","traffic","traffic_param","traffic_param_value2","model_no","mode", "mode_param", "throughput"]
    results_dict["results"] = result_list
    
    csv_foldername = topFolderName + "/Results/CSVs"
    pickle_foldername = topFolderName + "/Results/Pickles"
    os.makedirs(csv_foldername , exist_ok = True)
    os.makedirs(pickle_foldername , exist_ok = True)
    
    now = datetime.datetime.now()
    filename = filename_prefix + "_{}_{}_{}_{}_{}_{}.res".format(now.year, now.month, now.day, now.hour, now.minute, now.second)
    
    #write the pickle filegit commit -m 
    pickle.dump(results_dict, open(pickle_foldername + "/" + filename + ".p", "wb"))
    
    #now write the data as a csv file
    fp = open(csv_foldername + "/" + filename + ".csv", "w")
    txt = ",".join(results_dict["columns"])
    print(txt)
    fp.write(txt + "\n")
    for record in results_dict["results"]:
        txt = ",".join([str(x) for x in record])
        fp.write(txt + "\n")
        print(txt) 
    
    fp.close()
    
    end_t = time.time()
    elapsed = end_t - start_t
    
    print("total time: {} secs / {:.2f} mins".format(elapsed, elapsed/60))
    
    pass



if __name__ == "__main__":
    print("Hello world!")
    
    # experiment_mcf([9,17])
    experiment_mcf([9])
    # test_mcf()
    #inode_generator_test()
    
    print("The world never says hello back.")