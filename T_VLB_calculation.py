# -*- coding: utf-8 -*-
'''
Calculate T-VLB for (4,8,4,5)
find all possible path between two nodes
create min path dict between src and destination pair
create VLB path dict between src and destination pair
'''
from graphCreationAndDraw import create_topology,draw_graph_circular
from dragonfly_minpath import generate_global_link_list_for_all_group_pairs, min_path_for_an_SD_pair, min_paths_for_all_SD_pairs, path_distribution_overall, path_distribution_analytical, different_group_nodes
from randperm3 import get_traffic
from collections import defaultdict
import networkx as nx
import matplotlib.pyplot as plt
import copy

a,g=4,9
G = create_topology(a,g, arrangement = "absolute_improved")
plt.figure()
draw_graph_circular(G, a)


group_pair_vs_global_links_dict=generate_global_link_list_for_all_group_pairs(G,a)

def get_sd_min_path(i):
    if i==0:
        SD_pairs_vs_minpaths=min_paths_for_all_SD_pairs(G,a,group_pair_vs_global_links_dict)
        return SD_pairs_vs_minpaths
    else:
        return None
        
def plot_topo(H,title):
    plt.figure()
    plt.title(title)
    pos = nx.circular_layout(H)
    nx.draw(H,pos,with_labels=True)
    edge_labels = nx.get_edge_attributes(H, "weight")
    edge_labels = {k:round(v,2) for k,v in edge_labels.items()}
    nx.draw_networkx_edge_labels(H, pos, edge_labels)

def get_traffic_flows():     
    H = G.to_directed()
    for ele in H.edges:
        H.add_weighted_edges_from([(*ele,1)])
    plt.figure()
    pos = nx.circular_layout(H)
    nx.draw_networkx_nodes(H, pos)
    nx.draw_networkx_edges(H, pos)
    edge_labels = nx.get_edge_attributes(H, "weight")
    nx.draw_networkx_edge_labels(G, pos, edge_labels)
           
    sd_pair={}
    trf=get_traffic()
    trf=trf.split('\n')
    for ele in trf[:-1]:
        src =int(ele.split()[0])
        dest =int(ele.split()[1])
        sd_pair[(src,dest)]=1.0
    # assert(len(sd_pair)==(a**2)*g/2)
    iteration=0
    
    # while(1):
    links=defaultdict(int)
    link_flow=defaultdict(list)
    min_path_sd = {} # Store the min-path 
    
    ll=(0,0)
    temp_prev=0    
    SD_pairs_vs_minpaths = get_sd_min_path(iteration)
    to_remove = {}
    for ele_node in sd_pair:
        #convert sd node pair ele to sd router pair ele 
        router_ele=(int(ele_node[0]/int(a/2)),int(ele_node[1]/int(a/2)))
        #if src router and destination router are not same
        if(router_ele[0]!=router_ele[1]):
            #Get the min path for sd flow where min_path is a tuple data type
            if SD_pairs_vs_minpaths:
                min_path = SD_pairs_vs_minpaths[router_ele][0]
            else:
                try:
                    min_path = tuple(nx.shortest_path(H,router_ele[0],router_ele[1]))
                except:
                    print("****************************")
                    to_remove[ele_node] = sd_pair[ele_node]
                    print(to_remove)
                    break
            min_path_sd[ele_node] = min_path
            # This loop gives number of flows a link is sharing and also from where those flows are coming
            #add a picture
            for i in range(len(min_path[:-1])):
                # get the link in a path
                ll=(min_path[i],min_path[i+1])                
                #incremenet the link useage by 1
                links[ll] +=1
                if(ll==(26,30)):
                    print(min_path,links[ll])
                #ele[i] is not a src routter
                if i-1>=0:
                    link_flow[ll].append((min_path[i-1],min_path[i],min_path[i+1]))
                else:
                    link_flow[ll].append(('t-'+str(temp_prev),min_path[i],min_path[i+1]))
                    # print(('t-'+str(temp_prev),min_path[i],min_path[i+1]))
                    temp_prev+=1        
    
    sd_pair = {k:v for k,v in sd_pair.items() if k not in to_remove}

    #gives path max throughput of a min path
    min_path_max_flow=defaultdict(int)
    for ele_node in sd_pair:
        router_ele=(int(ele_node[0]/int(a/2)),int(ele_node[1]/int(a/2)))
        if(router_ele[0]!=router_ele[1]):
            min_path = min_path_sd[ele_node]
            for i in range(len(min_path[:-1])):
                ll=(min_path[i],min_path[i+1])
                min_path_max_flow[ele_node]=max(min_path_max_flow[ele_node],links[ll])
        else:
            print(ele_node, router_ele)
    
    #update the capacity of all links
    #first get the max injection load we can send from each source node
    min_path_max_load={}
    # sd_remaining_load={}

    current_graph_weight = nx.get_edge_attributes(H, "weight")
    bottleneckLink = min(current_graph_weight,key=current_graph_weight.get)
    bottleneckLink_cap = current_graph_weight[bottleneckLink] 
    
    #save the residual graph when the capacity of links are going to be fully used
    res_graph = copy.deepcopy(H)   
    res_graph_weight = nx.get_edge_attributes(res_graph, "weight")
    res_graph_weight = {k:v-bottleneckLink_cap for k,v in res_graph_weight.items()}
    for ele,v in res_graph_weight.items():
        res_graph.add_weighted_edges_from([(*ele,v)])
    #draw res graph
    plot_topo(res_graph,"res-graph-"+str(iteration))
     
    #update the network with bottleneck capacity so that all links have same capacity
    for ele,v in current_graph_weight.items():
        H.add_weighted_edges_from([(*ele,bottleneckLink_cap)])
    plot_topo(H,"bottleneck-H-"+str(iteration))
    
    #get max load we can push using min path (min_path_max_load) and the load that have to be send using nonmin path (sd_remaining_load)    
    for ele,max_flow in min_path_max_flow.items():        
        min_path_max_load[ele] = bottleneckLink_cap/float(max_flow)
        sd_pair[ele] -=  min_path_max_load[ele]
        # remaining_load = bottleneckLink_cap - min_path_max_load[ele]
        # if remaining_load:
        #     sd_remaining_load[ele] = remaining_load
        
    sd_pair = {k:v for k,v in sd_pair.items() if (v!=0 and int(k[0]/(a/2)) !=int(k[1]/(a/2)))}

    #update the network weight after we send traffic from min paths.
    #forward injection on links
    link_utilized=defaultdict(int)
    for k,v in min_path_max_load.items():
        pv = min_path_sd[k]
        for i in range(len(pv[:-1])):
            ll=(pv[i],pv[i+1])
            link_utilized[ll] += v 
       
    #all links capacity
    current_graph_weight = nx.get_edge_attributes(H, "weight")
    all_links_capacity=current_graph_weight
    for k,v in link_utilized.items():
        all_links_capacity[k] -= v
    
    #update the capacity of all links  
    for ele,v in all_links_capacity.items():
        all_links_capacity[ele]+=res_graph_weight[ele]
    
    
    for ele,v in all_links_capacity.items():
        H.add_weighted_edges_from([(*ele,v)])
    
    #round link capacity
    all_links_capacity={k:round(v,2) for k,v in all_links_capacity.items()}
    #delete links that have capacity 0 to carry load
    del_links = [ele for ele,v in all_links_capacity.items() if v<0.1]
    for ele in del_links:
        H.remove_edge(*ele)
        
    plot_topo(H,"H-"+str(iteration)) 
    
    iteration +=1


        
 
    

  

 

  
        
   
  
   
    
    
    
    

   
    
    
    for ele,v in sd_remaining_load.items():
        router_ele = (int(ele[0]/(a/2)),int(ele[1]/(a/2)))
        # try:
        path = nx.shortest_path(H,router_ele[0],router_ele[1])
        print(path,v)
        path_cap =[]
        for i in range(len(path[:-1])):
            path_cap.append(all_links_capacity[(path[i],path[i+1])])
        print(path_cap)
        # except:
        #     print("*******")
        #     print(ele , router_ele)


   
    all_links_capacity0 = {}
    for ele in H.edges:
        all_links_capacity0[ele]= all_links_capacity[ele]

    bottleneckLink = min(all_links_capacity0,key=all_links_capacity0.get)
    bottleneckLink_cap = all_links_capacity0[bottleneckLink]
    
        


def join_src_inmt_dest(src_inmt_paths,inmt_dest_paths):
    joined_paths=[]
    joined_paths_with_hops={}
    for path1 in src_inmt_paths:
        for path2 in inmt_dest_paths:
            assert path1[-1]==path2[0]
            path=path1+path2[1:]
            inmt_pos=len(path1)-1
            if path[inmt_pos-1]==path[inmt_pos+1]:
                path=path[0:inmt_pos]+path[inmt_pos+2:]
            if len(path)-1 not in joined_paths_with_hops:
                joined_paths_with_hops[len(path)-1]=[path]
            else:
                joined_paths_with_hops[len(path)-1].append(path)
            joined_paths.append(path)
    return joined_paths_with_hops
    
#get all hop path between source and destination given intermediate node ((s,d),inmt)
sd_pair_inmt_paths={} # ((0,24),9) will have list of vlb path from 0,24 if 9 is intermediate
for sd_pair in SD_pairs_vs_minpaths:
    if sd_pair[0]//a!=sd_pair[1]//a:
        for inmt_node in G.nodes():
            if inmt_node//a!=sd_pair[0]//a and inmt_node//a!=sd_pair[1]//a:
                #inmt_node is now not from source group and destination group is likeable to be a intemediate node
                src_inmt_paths=SD_pairs_vs_minpaths[(sd_pair[0],inmt_node)]
                inmt_dest_paths=SD_pairs_vs_minpaths[(inmt_node,sd_pair[1])]
                #join src_inmt_paths and src_inmt_paths
                src_dest_intemediate_paths=join_src_inmt_dest(src_inmt_paths,inmt_dest_paths)
                sd_pair_inmt_paths[(sd_pair,inmt_node)]=src_dest_intemediate_paths
                
                
                
def get_five_hop_path(sd_pair,sd_pair_inmt_paths,SD_pairs_vs_minpaths,a):
#count dict for plotting    
    no_five_hop_path=[]    
    min_path_routers=[x[1] for x in SD_pairs_vs_minpaths[sd_pair] if x[1]//a ==sd_pair[0]//a ]
    method3_VLB=set()
    VLB_five_hop=set()
    inmt_keys=list(sd_pair_inmt_paths.keys())
    sd_inmt=[]
    for aax in inmt_keys:
        if sd_pair in aax:
            sd_inmt.append(aax)
    
    for pp in sd_inmt:
        try:
            each_inmt_path=(list(sd_pair_inmt_paths[pp][5]))  #5 for five hop paths 
        except KeyError:
            no_five_hop_path.append(pp)
            continue
        # flat_list = [item for sublist in each_inmt_path for item in sublist]
        flat_list=each_inmt_path
        for x in flat_list:
            VLB_five_hop.add(x)
            if x[1] not in min_path_routers:
                
                method3_VLB.add(x)
               
                
    return VLB_five_hop,method3_VLB,no_five_hop_path

VLB_five_hop,method3_VLB=[],[]

link_5hop_count={}
m3_link_5hop_count={}


# temp_cnt=len(method3_VLB)
for sd_pair in SD_pairs_vs_minpaths.keys():
    VLB_five_hop_temp,method3_VLB_temp,no_five_hop_path=get_five_hop_path(sd_pair,sd_pair_inmt_paths,SD_pairs_vs_minpaths,a)
    temp_cnt1=len(VLB_five_hop)
    for x in VLB_five_hop_temp:
        VLB_five_hop.append(x)
    link_5hop_count[sd_pair]=len(VLB_five_hop)-temp_cnt1
    temp_cnt2=len(method3_VLB)
    for y in method3_VLB_temp:        
        method3_VLB.append(y) 
    m3_link_5hop_count[sd_pair]=len(method3_VLB)-temp_cnt2

import matplotlib.pyplot as plt
fig=plt.figure()
ax = fig.add_subplot(111)
five_hop_plt=ax.bar([i for i,_ in enumerate(link_5hop_count.keys())],link_5hop_count.values(),width=1, color='b')
m3_five_hop_plt=ax.bar(list(map(lambda x: x+1,[i for i,_ in enumerate(link_5hop_count.keys())])),m3_link_5hop_count.values(),width=1, color='r')
ax.set_ylabel('5 hop path counts')
ax.set_xlabel('SD_pairs')
ax.set_title('Number of 5 hop path for VLB vs M3_VLB') 
ax.legend( (five_hop_plt[0], m3_five_hop_plt[0]), ('VLB 5 hop', 'M3 5 hop') )
plt.show()



def write_dict(dict_to_write,name):
    import pickle
    with open(name,'wb') as outfile:
        pickle.dump(dict_to_write,outfile)
#write_dict(sd_pair_inmt_paths,'sd_pair_inmt_paths')
 


# total_path=0
# method3_path=0
# method3_VLB=set()
# total_VLB=set()

# temp_sd_pair=(12,35)
# min_path_routers=[x[1] for x in SD_pairs_vs_minpaths[temp_sd_pair] if x[1]//a ==temp_sd_pair[0]//a ]


# inmt_keys=list(sd_pair_inmt_paths.keys())
# sd_inmt=[]
# for aax in inmt_keys:
#     if temp_sd_pair in aax:
#         sd_inmt.append(aax)

# for pp in sd_inmt:
#     each_inmt_path=(list(sd_pair_inmt_paths[pp].values()))  
#     flat_list = [item for sublist in each_inmt_path for item in sublist]
#     for x in flat_list:
#         total_VLB.add(x)
#         if x[1] not in min_path_routers:
#             method3_VLB.add(x)
            
            
            
# method3_path=len(method3_VLB)
# total_path=len(total_VLB)


# vlb_router=set()
# for x in total_VLB:
#     vlb_router.add(x[1])
    
    
# m3_router=set()
# for x in method3_VLB:
#     m3_router.add(x[1])
    

    
'''
sd_pair_inmt_paths[((0,9),21)]
Out[225]: 
{3: [(0, 16, 8, 9), (0, 1, 17, 9)],
 4: [(0, 16, 21, 17, 9),
  (0, 16, 21, 13, 9),
  (0, 2, 18, 10, 9),
  (0, 3, 19, 11, 9),
  (0, 4, 20, 12, 9),
  (0, 5, 21, 17, 9),
  (0, 5, 21, 13, 9),
  (0, 6, 22, 14, 9),
  (0, 7, 23, 15, 9)],
 5: [(0, 16, 21, 18, 10, 9),
  (0, 16, 21, 19, 11, 9),
  (0, 16, 21, 20, 12, 9),
  (0, 16, 21, 22, 14, 9),
  (0, 16, 21, 23, 15, 9),
  (0, 1, 17, 21, 13, 9),
  (0, 2, 18, 21, 17, 9),
  (0, 2, 18, 21, 13, 9),
  (0, 3, 19, 21, 17, 9),
  (0, 3, 19, 21, 13, 9),
  (0, 4, 20, 21, 17, 9),
  (0, 4, 20, 21, 13, 9),
  (0, 5, 21, 16, 8, 9),
  (0, 5, 21, 18, 10, 9),
  (0, 5, 21, 19, 11, 9),
  (0, 5, 21, 20, 12, 9),
  (0, 5, 21, 22, 14, 9),
  (0, 5, 21, 23, 15, 9),
  (0, 6, 22, 21, 17, 9),
  (0, 6, 22, 21, 13, 9),
  (0, 7, 23, 21, 17, 9),
  (0, 7, 23, 21, 13, 9)],
 6: [(0, 1, 17, 21, 16, 8, 9),
  (0, 1, 17, 21, 18, 10, 9),
  (0, 1, 17, 21, 19, 11, 9),
  (0, 1, 17, 21, 20, 12, 9),
  (0, 1, 17, 21, 22, 14, 9),
  (0, 1, 17, 21, 23, 15, 9),
  (0, 2, 18, 21, 16, 8, 9),
  (0, 2, 18, 21, 19, 11, 9),
  (0, 2, 18, 21, 20, 12, 9),
  (0, 2, 18, 21, 22, 14, 9),
  (0, 2, 18, 21, 23, 15, 9),
  (0, 3, 19, 21, 16, 8, 9),
  (0, 3, 19, 21, 18, 10, 9),
  (0, 3, 19, 21, 20, 12, 9),
  (0, 3, 19, 21, 22, 14, 9),
  (0, 3, 19, 21, 23, 15, 9),
  (0, 4, 20, 21, 16, 8, 9),
  (0, 4, 20, 21, 18, 10, 9),
  (0, 4, 20, 21, 19, 11, 9),
  (0, 4, 20, 21, 22, 14, 9),
  (0, 4, 20, 21, 23, 15, 9),
  (0, 6, 22, 21, 16, 8, 9),
  (0, 6, 22, 21, 18, 10, 9),
  (0, 6, 22, 21, 19, 11, 9),
  (0, 6, 22, 21, 20, 12, 9),
  (0, 6, 22, 21, 23, 15, 9),
  (0, 7, 23, 21, 16, 8, 9),
  (0, 7, 23, 21, 18, 10, 9),
  (0, 7, 23, 21, 19, 11, 9),
  (0, 7, 23, 21, 20, 12, 9),
  (0, 7, 23, 21, 22, 14, 9)]}
'''

